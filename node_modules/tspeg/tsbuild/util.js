"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.indentBlock = indentBlock;
exports.altNames = altNames;
exports.writeBlock = writeBlock;
exports.unescapeSeqs = unescapeSeqs;
exports.escapeBackticks = escapeBackticks;
exports.getRuleFromGram = getRuleFromGram;
exports.assertValidRegex = assertValidRegex;
exports.usesEOF = usesEOF;
exports.flattenBlock = flattenBlock;
const meta_1 = require("./meta");
const checks_1 = require("./checks");
function indentBlock(blk) {
    return blk.filter((x) => x).map((x) => "    " + x);
}
function altNames(rd) {
    if (rd.rule.length === 1)
        return [rd.name];
    return rd.rule.map((_, i) => `${rd.name}_${i + 1}`);
}
function writeBlock(blk) {
    const res = [];
    for (const x of blk) {
        if (typeof x === "string") {
            res.push(x);
            continue;
        }
        const sub = indentBlock(writeBlock(x));
        res.push(...sub);
    }
    return res;
}
function unescapeSeqs(s) {
    let out = "";
    for (let i = 0; i < s.length; ++i) {
        if (s[i] !== "\\") {
            out += s[i];
            continue;
        }
        if (s[i + 1] === "{" || s[i + 1] === "}" || s[i + 1] === "\\") {
            out += s[i + 1];
        }
        else {
            throw new Error(`Unknown escape code \\${s[i + 1]}`);
        }
        ++i;
    }
    return out;
}
// escapeBackticks replaces backticks in strings with escaped backticks
// for use in inserting into a call to String.raw``
function escapeBackticks(s) {
    return s.replace('`', '\\`');
}
function getRuleFromGram(gram, name) {
    for (const rule of gram)
        if (rule.name === name)
            return rule;
    return null;
}
function assertValidRegex(s, start) {
    try {
        new RegExp(s);
    }
    catch (err) {
        throw new checks_1.CheckError(`Couldn't compile regex '${s}': ${err}`, start);
    }
}
function usesEOF(gram) {
    for (const rd of gram) {
        for (const alt of rd.rule) {
            for (const matchspec of alt.matches) {
                const match = matchspec.rule;
                if (match.kind === meta_1.ASTKinds.SPECIAL)
                    continue;
                const at = match.pre.at;
                if (at.kind === meta_1.ASTKinds.EOF)
                    return true;
            }
        }
    }
    return false;
}
function flattenBlock(ls) {
    return [].concat(...ls);
}
