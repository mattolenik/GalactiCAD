"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matchRule = matchRule;
exports.preRule = preRule;
exports.atomRule = atomRule;
exports.extractRules = extractRules;
const types_1 = require("./types");
const meta_1 = require("./meta");
const util_1 = require("./util");
function matchRule(expr) {
    // Check if special rule
    if (expr.kind === meta_1.ASTKinds.SPECIAL)
        return "this.mark()";
    if (expr.op === null)
        return preRule(expr.pre);
    if (expr.op.kind === meta_1.ASTKinds.RANGESPEC)
        return `this.loop<${(0, types_1.preType)(expr.pre)}>(() => ${preRule(expr.pre)}, ${expr.op.lb}, ${expr.op.ub})`;
    if (expr.op.kind === meta_1.ASTKinds.POSTOP_$0_1 && expr.op.op === "*")
        return `this.loop<${(0, types_1.preType)(expr.pre)}>(() => ${preRule(expr.pre)}, 0, -1)`;
    if (expr.op.kind === meta_1.ASTKinds.POSTOP_$0_1 && expr.op.op === "+")
        return `this.loopPlus<${(0, types_1.preType)(expr.pre)}>(() => ${preRule(expr.pre)})`;
    return preRule(expr.pre);
}
function preRule(expr) {
    if (expr.op && expr.op === "&")
        return `this.noConsume<${(0, types_1.atomType)(expr.at)}>(() => ${atomRule(expr.at)})`;
    if (expr.op && expr.op === "!")
        return `this.negate(() => ${atomRule(expr.at)})`;
    return atomRule(expr.at);
}
function atomRule(at) {
    if (at.kind === meta_1.ASTKinds.ATOM_1)
        return `this.match${at.name}($$dpth + 1, $$cr)`;
    if (at.kind === meta_1.ASTKinds.EOF)
        return 'this.match$EOF($$cr)';
    if (at.kind === meta_1.ASTKinds.ATOM_2) {
        // Ensure the regex is valid
        const mtch = at.match;
        (0, util_1.assertValidRegex)(mtch.val);
        const reg = "(?:" + mtch.val + ")";
        return `this.regexAccept(String.raw\`${(0, util_1.escapeBackticks)(reg)}\`, "${mtch.mods}", $$dpth + 1, $$cr)`;
    }
    const subname = at.name;
    if (subname)
        return `this.match${subname}($$dpth + 1, $$cr)`;
    return "ERR";
}
// extractRule does a traversal of the AST assigning names to
// subrules. It takes subrules and assigns
// them their own Ruledef in the grammar, effectively flattening the
// structure of the grammar.
function extractRules(rule, name, pos) {
    let cnt = 0;
    const rules = [{ name, rule, pos }];
    for (const alt of rule) {
        for (const match of alt.matches) {
            // Check if special rule
            if (match.rule.kind === meta_1.ASTKinds.SPECIAL)
                continue;
            // Check if not a subrule
            const at = match.rule.pre.at;
            if (at === null || at.kind !== meta_1.ASTKinds.ATOM_3)
                continue;
            const subrule = at.sub;
            const nm = `${name}_$${cnt}`;
            at.name = nm;
            const rdfs = extractRules(subrule.list, nm);
            rules.push(...rdfs);
            ++cnt;
        }
    }
    return rules;
}
