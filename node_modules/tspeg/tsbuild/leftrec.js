"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ruleIsNullableInCtx = ruleIsNullableInCtx;
exports.nullableAtomSet = nullableAtomSet;
exports.leftRecRules = leftRecRules;
exports.leftRecCycles = leftRecCycles;
exports.disjointCycleSets = disjointCycleSets;
exports.getRulesToMarkForBoundedRecursion = getRulesToMarkForBoundedRecursion;
const util_1 = require("./util");
const meta_1 = require("./meta");
const checks_1 = require("./checks");
/*
 * As there are cyclic dependencies between rules we use the concept of a context
 * to compute which ATOM's are nullable, a context is a set of ATOM's we currently consider
 * nullable, we then incrementally update this context until we reach a fixed point
 */
// ruleIsNullableInCtx returns if a given rule is nullable within the given context
function ruleIsNullableInCtx(r, nullableAtoms) {
    for (const alt of r) {
        let allNullable = true;
        for (const matchspec of alt.matches)
            if (!matchIsNullableInCtx(matchspec.rule, nullableAtoms))
                allNullable = false;
        if (allNullable)
            return true;
    }
    return false;
}
// matchIsNullableInCtx returns if a given `MATCH` is nullable within the given context
function matchIsNullableInCtx(match, nullableAtoms) {
    var _a;
    if (match.kind === meta_1.ASTKinds.SPECIAL)
        return true;
    // match is a POSTOP
    // match is nullable if these are the postops
    if (((_a = match.op) === null || _a === void 0 ? void 0 : _a.kind) === meta_1.ASTKinds.POSTOP_$0_1 && (match.op.op === "?" || match.op.op === "*"))
        return true;
    const preop = match.pre;
    // Negations of nullables are invalid grammar expressions
    if (preop.op === "!" && nullableAtoms.has(preop.at))
        throw new checks_1.CheckError("Cannot negate a nullable expression", preop.start);
    // Always nullable, doesn't match anything
    if (preop.op !== null)
        return true;
    if (nullableAtoms.has(preop.at))
        return true;
    return false;
}
// This function updates our nullableAtoms context to the next step of the iterative process
function updateNullableAtomsInRule(rule, gram, nullableAtoms) {
    for (const alt of rule) {
        for (const matchspec of alt.matches) {
            const match = matchspec.rule;
            if (match.kind === meta_1.ASTKinds.SPECIAL)
                continue;
            const at = match.pre.at;
            // Already in set, ignore
            if (nullableAtoms.has(at))
                continue;
            if (at.kind === meta_1.ASTKinds.ATOM_1) {
                // Rule reference, get rule and add to set if rule is nullable
                const namedRule = (0, util_1.getRuleFromGram)(gram, at.name);
                if (namedRule === null)
                    continue;
                if (ruleIsNullableInCtx(namedRule.rule, nullableAtoms))
                    nullableAtoms.add(at);
            }
            if (at.kind === meta_1.ASTKinds.ATOM_2) {
                // Regex literal, we just test if "" matches to test if nullable
                (0, util_1.assertValidRegex)(at.match.val, at.match.start);
                const reg = new RegExp(at.match.val);
                if (reg.test("")) // Is nullable
                    nullableAtoms.add(at);
            }
            if (at.kind === meta_1.ASTKinds.ATOM_3 && ruleIsNullableInCtx(at.sub.list, nullableAtoms))
                // Subrule, recurse
                nullableAtoms.add(at);
        }
    }
}
// Compute all nullable atoms, start with empty context and then iteratively expand
// the set until a fixed point is reached.
function nullableAtomSet(gram) {
    // Inefficient approach but it doesn't matter
    const nullable = new Set();
    for (;;) {
        const oldSize = nullable.size;
        for (const ruledef of gram)
            updateNullableAtomsInRule(ruledef.rule, gram, nullable);
        const newSize = nullable.size;
        if (newSize === oldSize)
            break;
    }
    return nullable;
}
// leftRecEdges returns a set of Rule names that a given Rule calls "on the left"
// (with a given nullable atoms context).
function leftRecEdges(r, nullableAtoms) {
    const out = new Set();
    for (const alt of r) {
        // Loop as long as matches are nullable
        for (const matchspec of alt.matches) {
            const mtch = matchspec.rule;
            // Pos matches don't need searching
            if (mtch.kind === meta_1.ASTKinds.SPECIAL)
                continue;
            const at = mtch.pre.at;
            if (at.kind === meta_1.ASTKinds.ATOM_1)
                out.add(at.name);
            if (at.kind === meta_1.ASTKinds.ATOM_3)
                for (const edge of leftRecEdges(at.sub.list, nullableAtoms))
                    out.add(edge);
            // Break if no longer nullable
            if (!matchIsNullableInCtx(mtch, nullableAtoms))
                break;
        }
    }
    return out;
}
// leftRecGraph returns a graph object containing all direct left recursion edges.
// (with a given nullable atoms context).
function leftRecGraph(gram, nullableAtoms) {
    return new Map(gram.map(r => [r.name, leftRecEdges(r.rule, nullableAtoms)]));
}
// leftRecClosure uses the left recursion graph to extend direct rule references to a graph
// with all indirect references.
function leftRecClosure(gram, nullableAtoms) {
    const grph = leftRecGraph(gram, nullableAtoms);
    return transitiveClosure(grph);
}
// transitiveClosure implements Floyd Warshall algorithm
function transitiveClosure(grph) {
    for (const [kName, kEdges] of grph.entries())
        for (const aEdges of grph.values())
            for (const bName of grph.keys())
                if (aEdges.has(kName) && kEdges.has(bName))
                    aEdges.add(bName);
    return grph;
}
// leftRecRules returns all left recursive rules within a grammar.
function leftRecRules(g) {
    const s = new Set();
    const nullAtoms = nullableAtomSet(g);
    const cls = leftRecClosure(g, nullAtoms);
    for (const [k, v] of cls.entries())
        if (v.has(k))
            s.add(k);
    return s;
}
// cycleEq checks if two cycles are equal (two equivalent cycles
// can be shifted around by some amount).
function cycleEq(a, b) {
    if (a.length !== b.length)
        return false;
    const bOffset = b.indexOf(a[0]);
    if (bOffset === -1)
        return false;
    for (let i = 0; i < a.length; ++i)
        if (a[i] !== b[(bOffset + i) % b.length])
            return false;
    return true;
}
// addCycle adds a cycle to the cycles list if it's not present.
function addCycle(cycles, cyc) {
    for (const c of cycles)
        if (cycleEq(c, cyc))
            return;
    cycles.push(cyc);
}
// leftRecCycles returns all left recursion cycles in a given grammar
// (within a given nullable atom context).
function leftRecCycles(gram, nullableAtoms) {
    const cycles = [];
    const grph = leftRecGraph(gram, nullableAtoms);
    const vis = new Set();
    const seq = [];
    const cycleRec = (cur, tgt) => {
        if (vis.has(cur)) {
            if (cur === tgt)
                addCycle(cycles, [...seq]);
            return;
        }
        const edges = grph.get(cur);
        if (edges === undefined)
            return;
        vis.add(cur);
        seq.push(cur);
        for (const k of edges)
            cycleRec(k, tgt);
        vis.delete(cur);
        seq.pop();
    };
    for (const g of gram) {
        vis.clear();
        cycleRec(g.name, g.name);
    }
    return cycles;
}
// disjointCycleSets uses UFDS algorithm to compute disjoint sets of
// left recursive cycles, this is to break the marking of single elements down
// into simpler subproblems if possible.
function disjointCycleSets(cycles) {
    const p = new Map();
    const find = (a) => {
        var _a;
        const pa = (_a = p.get(a)) !== null && _a !== void 0 ? _a : a;
        const res = pa === a ? a : find(pa);
        p.set(a, res);
        return res;
    };
    const union = (a, b) => {
        p.set(find(a), find(b));
    };
    for (const a of cycles) {
        const sa = new Set(a);
        for (const b of cycles) {
            const sb = new Set(b);
            if ([...a, ...b].filter(x => sa.has(x) && sb.has(x)).length !== 0)
                union(a, b);
        }
    }
    const sets = [];
    for (const a of cycles) {
        if (p.get(a) !== a)
            continue;
        const st = [];
        for (const b of cycles)
            if (find(b) === a)
                st.push(b);
        sets.push(st);
    }
    return sets;
}
// getRulesToMarkForBoundedRecursion takes a grammar and returns a Set of rule names
// that should be computed with bounded recursion memoisation.
// Bounded recursion memoisation logic is used to support left recursion, however it
// only works if exactly one rule in each left recursion cycle implements it.
// This function brute forces the assignment of marked rules to find a suitable
// assignment.
function getRulesToMarkForBoundedRecursion(g) {
    const marked = new Set();
    const nullAtoms = nullableAtomSet(g);
    const cycles = leftRecCycles(g, nullAtoms);
    const sets = disjointCycleSets(cycles);
    // Loop over all subproblems (disjoint sets of cycles)
    for (const st of sets) {
        // All rules used in the set
        const allRulesSet = new Set(st.reduce((x, y) => x.concat(y)));
        const allRules = [...allRulesSet];
        const sz = allRules.length;
        // Check that left recursion sets are small enough to brute force
        // 2^18 == 262144
        if (sz > 18)
            throw new checks_1.CheckError("Left recursion is too complex to solve");
        // Brute force all subsets
        const lim = 1 << sz;
        for (let subsetIdx = 0; subsetIdx < lim; ++subsetIdx) {
            // Check that each cycle in st has exactly one rule in subset
            const subst = new Set();
            for (let i = 0; i < sz; ++i)
                if ((subsetIdx & (1 << i)) !== 0)
                    subst.add(allRules[i]);
            // Check that all cycles have exactly one marked rule.
            const success = st.every(cyc => cyc.filter(x => subst.has(x)).length === 1);
            if (!success)
                continue;
            // Assignment found for st
            for (const rule of subst)
                marked.add(rule);
            break;
        }
    }
    return marked;
}
