"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Generator = exports.SyntaxErrs = void 0;
exports.getMatchedSubstr = getMatchedSubstr;
exports.buildParser = buildParser;
const meta_1 = require("./meta");
const template_1 = require("./template");
const util_1 = require("./util");
const checks_1 = require("./checks");
const types_1 = require("./types");
const rules_1 = require("./rules");
const leftrec_1 = require("./leftrec");
function hasAttrs(alt) {
    return alt.attrs.length > 0;
}
// addScope adds a prefix that uses illegal characters to
// ensure namespace separation wrt generated vs user supplied IDs
function addScope(id) {
    return "$scope$" + id;
}
function memoName(id) {
    return addScope(id + "$memo");
}
function getNamedTypes(alt) {
    const types = [];
    for (const match of alt.matches) {
        if (!match.named)
            continue;
        const rn = (0, types_1.matchType)(match.rule);
        types.push([match.named.name, rn]);
    }
    return types;
}
// Rules with no named matches, no attrs and only one match are rule aliases
function isAlias(alt) {
    return getNamedTypes(alt).length === 0 && alt.matches.length === 1 && !hasAttrs(alt);
}
function memoedBody(memo, body) {
    return [
        'return this.memoise(',
        [
            '() => {',
            body,
            '},',
            `this.${memoName(memo)},`,
        ],
        ');',
    ];
}
function getMatchedSubstr(t, inputStr) {
    return inputStr.substring(t.start.overallPos, t.end.overallPos);
}
// We use a class so we can do an instanceof check
class SyntaxErrs {
    constructor(errs) {
        this.errs = errs;
    }
}
exports.SyntaxErrs = SyntaxErrs;
class Generator {
    constructor(input, numEnums = false, enableMemos = false, regexFlags = "", includeGrammar = true) {
        var _a, _b;
        this.checkers = [];
        this.input = input;
        this.numEnums = numEnums;
        this.enableMemos = enableMemos;
        this.regexFlags = regexFlags;
        this.includeGrammar = includeGrammar;
        const p = new meta_1.Parser(this.input);
        const res = p.parse();
        if (res.errs.length > 0)
            throw new SyntaxErrs(res.errs);
        if (!res.ast)
            throw new Error("No AST found");
        this.expandedGram = this.astToExpandedGram(res.ast);
        this.unexpandedGram = res.ast.rules.map(def => {
            return {
                name: def.name,
                rule: def.rule.list,
                pos: def.namestart,
            };
        });
        this.header = (_b = (_a = res.ast.header) === null || _a === void 0 ? void 0 : _a.content) !== null && _b !== void 0 ? _b : null;
        this.boundedRecRules = (0, leftrec_1.getRulesToMarkForBoundedRecursion)(this.unexpandedGram);
    }
    astToExpandedGram(g) {
        const gram = g.rules.map(def => (0, rules_1.extractRules)(def.rule.list, def.name, def.namestart));
        return gram.reduce((x, y) => x.concat(y));
    }
    addChecker(c) {
        this.checkers.push(c);
        return this;
    }
    writeKinds() {
        const astKinds = [].concat(...this.expandedGram.map(util_1.altNames));
        if ((0, util_1.usesEOF)(this.expandedGram))
            astKinds.push("$EOF");
        return [
            "export enum ASTKinds {",
            this.numEnums
                ? astKinds.map(x => `${x},`)
                : astKinds.map(x => `${x} = "${x}",`),
            "}",
        ];
    }
    memoRules() {
        return this.enableMemos
            ? this.expandedGram
            : this.expandedGram
                .filter(rule => this.boundedRecRules.has(rule.name));
    }
    writeMemos() {
        return this.memoRules().map(rule => `protected ${memoName(rule.name)}: Map<number, [Nullable<${rule.name}>, PosInfo]> = new Map();`);
    }
    writeMemoClearFn() {
        const ls = this.memoRules().map(rule => `this.${memoName(rule.name)}.clear();`);
        return [
            'public clearMemos(): void {',
            ls,
            '}',
        ];
    }
    writeChoice(name, alt) {
        const namedTypes = getNamedTypes(alt);
        if (isAlias(alt)) {
            const at = alt.matches[0].rule;
            return [`export type ${name} = ${(0, types_1.matchType)(at)};`];
        }
        // If we have computed properties, then we need a class, not an interface.
        if (hasAttrs(alt)) {
            return [
                `export class ${name} {`,
                [
                    `public kind: ASTKinds.${name} = ASTKinds.${name};`,
                    ...namedTypes.map((x) => `public ${x[0]}: ${x[1]};`),
                    ...alt.attrs.map((x) => `public ${x.name}: ${getMatchedSubstr(x.type, this.input)};`),
                    `constructor(${namedTypes.map((x) => `${x[0]}: ${x[1]}`).join(", ")}){`,
                    namedTypes.map((x) => `this.${x[0]} = ${x[0]};`),
                    ...alt.attrs.map(x => [`this.${x.name} = ((): ${getMatchedSubstr(x.type, this.input)} => {`,
                        getMatchedSubstr(x.code, this.input).trim(),
                        "})();"]),
                    "}",
                ],
                "}",
            ];
        }
        return [
            `export interface ${name} {`,
            [
                `kind: ASTKinds.${name};`,
                ...namedTypes.map((x) => `${x[0]}: ${x[1]};`),
            ],
            "}",
        ];
    }
    writeRuleClass(ruledef) {
        const nm = ruledef.name;
        const union = (0, util_1.altNames)(ruledef);
        const choices = [];
        (0, util_1.altNames)(ruledef).forEach((name, i) => {
            choices.push(...this.writeChoice(name, ruledef.rule[i]));
        });
        const typedef = ruledef.rule.length > 1 ? [`export type ${nm} = ${union.join(" | ")};`] : [];
        return [...typedef, ...choices];
    }
    writeRuleClasses(gram) {
        const types = [];
        const rules = [];
        for (const ruledef of gram) {
            types.push(ruledef.name);
            rules.push(...this.writeRuleClass(ruledef));
        }
        return rules;
    }
    writeParseIfStmt(alt) {
        const checks = [];
        for (const match of alt.matches) {
            const expr = match.rule;
            const rn = (0, rules_1.matchRule)(expr);
            if (match.named) {
                // Optional match
                if (expr.kind !== meta_1.ASTKinds.SPECIAL && expr.optional) {
                    checks.push(`&& ((${addScope(match.named.name)} = ${rn}) || true)`);
                }
                else {
                    checks.push(`&& (${addScope(match.named.name)} = ${rn}) !== null`);
                }
            }
            else {
                // Optional match
                if (expr.kind !== meta_1.ASTKinds.SPECIAL && expr.optional) {
                    checks.push(`&& ((${rn}) || true)`);
                }
                else {
                    checks.push(`&& ${rn} !== null`);
                }
            }
        }
        return checks;
    }
    writeRuleAliasFnBody(expr) {
        return [
            `return ${(0, rules_1.matchRule)(expr)};`,
        ];
    }
    writeChoiceParseFn(name, alt, memo = false) {
        return [`public match${name}($$dpth: number, $$cr?: ErrorTracker): Nullable<${name}> {`,
            memo
                ? memoedBody(name, this.writeChoiceParseFnBody(name, alt))
                : this.writeChoiceParseFnBody(name, alt),
            "}",
        ];
    }
    getUnnamedTypes(alt) {
        const types = [];
        for (const match of alt.matches) {
            if (match.named)
                continue;
            const rn = (0, types_1.matchType)(match.rule);
            types.push(rn);
        }
        return types;
    }
    writeChoiceParseFnBody(name, alt) {
        const namedTypes = getNamedTypes(alt);
        if (isAlias(alt))
            return this.writeRuleAliasFnBody(alt.matches[0].rule);
        return [
            `return this.run<${name}>($$dpth,`,
            [
                "() => {",
                [
                    ...namedTypes.map((x) => `let ${addScope(x[0])}: Nullable<${x[1]}>;`),
                    `let $$res: Nullable<${name}> = null;`,
                    "if (true",
                    this.writeParseIfStmt(alt),
                    ") {",
                    [
                        hasAttrs(alt)
                            ? `$$res = new ${name}(${namedTypes.map(x => addScope(x[0])).join(", ")});`
                            : `$$res = {kind: ASTKinds.${name}, ${namedTypes.map(x => `${x[0]}: ${addScope(x[0])}`).join(", ")}};`,
                    ],
                    "}",
                    "return $$res;",
                ],
                "});",
            ],
        ];
    }
    writeLeftRecRuleParseFn(name, body) {
        const memo = memoName(name);
        const posVar = addScope("pos");
        const oldMemoSafe = addScope("oldMemoSafe");
        const t = [`public match${name}($$dpth: number, $$cr?: ErrorTracker): Nullable<${name}> {`,
            [
                'const fn = () => {',
                body,
                '};',
                `const ${posVar} = this.mark();`,
                `const memo = this.${memo}.get(${posVar}.overallPos);`,
                'if(memo !== undefined) {',
                '    this.reset(memo[1]);',
                '    return memo[0];',
                '}',
                `const ${oldMemoSafe} = this.memoSafe;`,
                'this.memoSafe = false;',
                `this.${memo}.set(${posVar}.overallPos, [null, ${posVar}]);`,
                `let lastRes: Nullable<${name}> = null;`,
                `let lastPos: PosInfo = ${posVar};`,
                'for(;;) {',
                [
                    `this.reset(${posVar});`,
                    'const res = fn();',
                    'const end = this.mark();',
                    'if(end.overallPos <= lastPos.overallPos)',
                    [
                        'break;',
                    ],
                    'lastRes = res;',
                    'lastPos = end;',
                    `this.${memo}.set(${posVar}.overallPos, [lastRes, lastPos]);`,
                ],
                '}',
                'this.reset(lastPos);',
                `this.memoSafe = ${oldMemoSafe};`,
                'return lastRes;',
            ],
            '}'];
        return t;
    }
    writeRuleParseFns(ruledef) {
        const nm = ruledef.name;
        const nms = (0, util_1.altNames)(ruledef);
        if (this.boundedRecRules.has(nm)) {
            if (nms.length === 1) {
                // Only 1, skip the union
                const body = this.writeChoiceParseFnBody(nms[0], ruledef.rule[0]);
                if (nm !== nms[0])
                    throw `${nm} != ${nms[0]}`;
                const fn = this.writeLeftRecRuleParseFn(nm, body);
                return fn;
            }
            const body = this.writeUnionParseBody(nm, nms);
            const fn = this.writeLeftRecRuleParseFn(nm, body);
            const choiceFns = (0, util_1.flattenBlock)(nms.map((name, i) => this.writeChoiceParseFn(name, ruledef.rule[i])));
            return [...fn, ...choiceFns];
        }
        if (ruledef.rule.length <= 1)
            return this.writeChoiceParseFn(nm, ruledef.rule[0], this.enableMemos);
        const union = this.writeUnionParseFn(nm, nms, this.enableMemos);
        const choiceFns = (0, util_1.flattenBlock)(nms.map((name, i) => this.writeChoiceParseFn(name, ruledef.rule[i])));
        return [...union, ...choiceFns];
    }
    writeUnionParseFn(name, alts, memo = false) {
        return [
            `public match${name}($$dpth: number, $$cr?: ErrorTracker): Nullable<${name}> {`,
            memo
                ? memoedBody(name, this.writeUnionParseBody(name, alts))
                : this.writeUnionParseBody(name, alts),
            `}`,
        ];
    }
    writeUnionParseBody(name, alts) {
        return [
            `return this.choice<${name}>([`,
            alts.map(x => `() => this.match${x}($$dpth + 1, $$cr),`),
            `]);`,
        ];
    }
    writeAllRuleParseFns(gram) {
        const fns = [];
        for (const ruledef of gram)
            fns.push(...this.writeRuleParseFns(ruledef));
        const S = gram[0].name;
        return [...fns,
            "public test(): boolean {",
            [
                "const mrk = this.mark();",
                `const res = this.match${S}(0);`,
                "const ans = res !== null;",
                "this.reset(mrk);",
                "return ans;",
            ],
            "}",
            "public parse(): ParseResult {",
            [
                "const mrk = this.mark();",
                `const res = this.match${S}(0);`,
                "if (res)",
                [
                    "return {ast: res, errs: []};",
                ],
                "this.reset(mrk);",
                "const rec = new ErrorTracker();",
                "this.clearMemos();",
                `this.match${S}(0, rec);`,
                "const err = rec.getErr()",
                "return {ast: res, errs: err !== null ? [err] : []}",
            ],
            "}",
        ];
    }
    writeParseResultClass(gram) {
        const head = gram[0];
        const startname = head.name;
        return ["export interface ParseResult {",
            [
                `ast: Nullable<${startname}>;`,
                "errs: SyntaxErr[];",
            ],
            "}",
        ];
    }
    generate() {
        // TODO Support throwing more checks than one.
        for (const checker of this.checkers) {
            const err = checker.Check(this.expandedGram, this.input);
            if (err)
                throw err;
        }
        const hdr = this.header ? [this.header] : [];
        const parseBlock = (0, template_1.expandTemplate)({
            inputStr: this.input,
            header: hdr,
            memos: this.writeMemos(),
            memoClearFn: this.writeMemoClearFn(),
            kinds: this.writeKinds(),
            regexFlags: this.regexFlags,
            ruleClasses: this.writeRuleClasses(this.expandedGram),
            ruleParseFns: this.writeAllRuleParseFns(this.expandedGram),
            parseResult: this.writeParseResultClass(this.expandedGram),
            usesEOF: (0, util_1.usesEOF)(this.expandedGram),
            includeGrammar: this.includeGrammar,
        });
        return (0, util_1.writeBlock)(parseBlock).join("\n");
    }
}
exports.Generator = Generator;
function buildParser(s, numEnums, enableMemos, regexFlags, includeGrammar = true) {
    const gen = new Generator(s, numEnums, enableMemos, regexFlags, includeGrammar)
        .addChecker(checks_1.BannedNamesChecker)
        .addChecker(checks_1.RulesExistChecker)
        .addChecker(checks_1.NoRuleNameCollisionChecker)
        .addChecker(checks_1.NoKeywords);
    return gen.generate();
}
